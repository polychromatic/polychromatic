#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015-2018 Luke Horwell <code@horwell.me>
#               2015-2016 Terry Cain <terry@terrys-home.co.uk>

"""Polychromatic GUI for interfacing with the OpenRazer's Python Library and daemon"""

version = "0.4.0"

import argparse
import gettext
import glob
import os
import re
import signal
import sys
import threading
import time
from setproctitle import setproctitle
from subprocess import Popen as background_process
from subprocess import check_output
from platform import linux_distribution

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
gi.require_version("WebKit2", "4.0")
from gi.repository import GLib, Gtk, Gdk, WebKit2

setproctitle("polychromatic-controller")

try:
    import openrazer.client as rclient
except ImportError as e:
    rclient = None
    print("Failed to import modules for daemon.\n" + e.message)

# Import relative copies if running in development mode.
dev_version = False
if os.path.exists(os.path.dirname(__file__) + "/pylib/"):
    dev_version = True
    try:
        # Relative (for development)
        import pylib.preferences as pref
        import pylib.profiles as prof
        import pylib.common as common
        import pylib.uicallback as uicallback
    except (ImportError, Exception) as e:
        print("Failed to import modules relatively.\n")
        print(e)
        exit(1)

# Import modules if installed to system.
else:
    version = version + "-stable"
    try:
        import polychromatic.preferences as pref
        import polychromatic.profiles as prof
        import polychromatic.common as common
        import polychromatic.uicallback as uicallback
    except (ImportError, Exception) as e:
        print("Polychromatic's modules could not be imported.")
        print("Check all dependencies are installed, the Python environment variables are correct, or try re-installing the application.\n")
        print(e)
        exit(1)

path = pref.Paths()
path.data_source = path.get_data_source(__file__)

def get_string_bank(_):
    return {
        "debug1": "Hello World",
        "debug2": "Test String",
        "overview": _("All Devices"),
        "devices": _("Devices"),
        "effects": _("Effects"),
        "profiles": _("Profiles"),
        "schedule": _("Schedule"),
        "preferences": _("Preferences"),
        "device-info": _("Device Info"),
        "brightness": _("Brightness"),
        "effect": _("Effect"),
        "spectrum": _("Spectrum"),
        "wave": _("Wave"),
        "reactive": _("Reactive"),
        "breath": _("Breath"),
        "ripple": _("Ripple"),
        "static": _("Static"),
        "starlight": _("Starlight"),
        "game_mode": _("Game Mode"),
        "enabled": _("Enabled"),
        "learn_more": _("Learn more"),
        "macros": _("Macros"),
        "dpi": _("DPI"),
        "polling_rate": _("Polling Rate"),
        "wave-settings": _("Wave Direction"),
        "left": _("Left"),
        "right": _("Right"),
        "clockwise": _("Clockwise"),
        "anticlockwise": _("Anticlockwise"),
        "up": _("Up"),
        "down": _("Down"),
        "reactive-settings": _("Reactive Speed"),
        "fast": _("Fast"),
        "medium": _("Medium"),
        "slow": _("Slow"),
        "vslow": _("Very Slow"),
        "breath-settings": _("Breath Type"),
        "random": _("Random"),
        "single": _("Single"),
        "dual": _("Dual"),
        "ripple-settings": _("Ripple Type"),
        "color": _("Color"),
        "unknown-device": _("Unrecognized"),
        "close-app": _("Close Application"),
        "troubleshoot": _("Troubleshoot"),
        "retry": _("Retry"),
        "on": _("On"),
        "off": _("Off"),
        "formfactor": _("Form Factor"),
        "serial": _("Serial"),
        "firmware_version": _("Firmware Version"),
        "macro_support": _("Macro Support"),
        "matrix_size": _("Matrix Dimensions"),
        "capability_name": _("Daemon Capability"),
        "capability_supported": _("Supported?"),
        "capability_description": _("Description"),
        "connected-devices": _("Connected Devices"),
        "apply-to-all": _("Apply to All")
    }


class WebView(WebKit2.WebView):
    """
    WebView class responsible for rendering the user interface using web technologies.
    """
    def __init__(self):
        """Initalises WebKit and loads the base HTML page."""
        webkit = WebKit2
        webkit.WebView.__init__(self)
        self.set_background_color(Gdk.RGBA(0, 0, 0, 1))

        # Post-actions after pages fully load.
        self.connect("load-changed", self.load_changed_cb)
        self.connect("notify::title", self.title_changed_cb)
        self.connect("context-menu", self.context_menu_cb)

        try:
            # Allows local SVG files to load.
            self.get_settings().set_allow_file_access_from_file_urls(True)
            try:
                self.get_settings().set_allow_universal_access_from_file_urls(True)
            except AttributeError:
                dbg.stdout("Ignoring set_allow_universal_access_from_file_urls because the WebKit2GTK version is <2.14.", dbg.warning, 1)

            # Print console log errors to stdout if verbose
            if dbg.verbose_level >= 1:
                self.get_settings().set_enable_write_console_messages_to_stdout(True)

            # Basic accessibility - keyboard navigation
            self.get_settings().set_enable_spatial_navigation(True)
            self.get_settings().set_enable_caret_browsing(True)

        except AttributeError as e:
            dbg.stdout("WebKit2GTK failed to initialise!", dbg.error)
            print("Your distribution may be using an older version of this library.")
            print("For example, Debian/Ubuntu provides this in 'gir1.2-webkit-4.0'\n")
            dbg.stdout("The exception was: {0}\n".format(str(e)), dbg.error)
            exit(1)

        # Enable web inspector for debugging
        if dbg.verbose_level == 3:
            self.get_settings().set_property("enable-developer-extras", True)
            inspector = self.get_inspector()
            inspector.show()

        # Load the base page structure
        self.load_uri("file://" + os.path.join(path.data_source, "ui/controller.html"))
        dbg.stdout("WebView Initialised", dbg.success, 1)

    def run_js(self, function):
        """
        Runs a JavaScript function on the page, regardless of which thread it is called from.
        GTK+ operations must be performed on the same thread to prevent crashes.
        """
        GLib.idle_add(self._run_js, function)

    def _run_js(self, function):
        """
        Private function for running a JavaScript function on the page when invoked from run_js()
        """
        self.run_javascript(function)
        return GLib.SOURCE_REMOVE

    def title_changed_cb(self, view, frame):
        """
        Callback: Title changed

        This is where the frontend has set document.title, which is used for
        communicating to Python via commands.
        """
        title = self.get_title()
        if title not in ["null", None, "", " "]:
            app.process_command(title)

    def context_menu_cb(self, view, menu, event, htr):
        """
        Callback: Disables the context menu.
        """
        return True

    def load_changed_cb(self, view, frame):
        """
        Callback: Page changed

        Intended to be called when the initial controller.html page has finished loading.
        """
        dbg.stdout("WebView still loading...", dbg.debug, 2)
        if not self.is_loading():
            dbg.stdout("WebView Ready.", dbg.success, 1)
            thread = threading.Thread(target=app.start_loading, args=([view]))
            thread.start()


class AppWindow(object):
    """
    Main application class for building the skeleton of the GTK application window.
    """
    def __init__(self):
        """
        Variables to be set later.
        """
        self.webkit = None
        self.window = None

    def run(self):
        """
        Assembles the main application window.
        """
        self.webkit = WebView()
        self.window = Gtk.Window(title=_("Polychromatic Controller"))
        self.window.set_wmclass("polychromatic-controller", "polychromatic-controller")
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.modify_bg(Gtk.StateType(0), Gdk.Color(0, 0, 0))
        self.window.set_size_request(1000, 600)

        try:
            self.window.set_icon_from_file(os.path.join(path.data_source, "ui/img/general/controller.svg"))
        except Exception:
            dbg.stdout("Failed to set window icon.", dbg.warning, 2)

        # Add elements to window
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw.add(self.webkit)

        # Compatibility option if DEs don't scale to HIDPI displays automatically.
        scale2x = float(pref.get("editor", "scale2x", False))
        if scale2x:
            self.webkit.set_zoom_level(1.5)
            self.window.set_size_request(1500, 900)
            dbg.stdout("HIDPI compatibility enabled", dbg.action, 1)

        # Build an auto expanding box and add the scrolled window
        b = Gtk.VBox(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)
        self.window.add(b)
        self.window.connect("delete-event", Gtk.main_quit)
        self.window.show_all()
        dbg.stdout("Window Initialised", dbg.success, 1)

        # Kills process when CTRL+C'd.
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()


class Controller(object):
    """
    The main application runtime. Responsive for populating the UI and user interaction logic.
    """
    def __init__(self):
        """
        Variables are assigned later in start_loading()
        """
        self.webkit = None
        self.devman = None
        self.active_device = None
        self.active_device_id = None
        self.uicmd = None

    def run_javascript(self, function):
        """
        Sends a JavaScript function to the page.
        """
        self.webkit.run_js(function)

    def update_page(self, element, function, parm1=None, parm2=None):
        """
        Sends a jQuery function to the page, ensuring correctly parsed quotes.
        """
        if parm1 and parm2:
            buffer = '$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')"
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)
        if parm1:
            buffer = '$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')"
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)
        else:
            buffer = '$("' + element + '").' + function + '()'
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)

    def get_content_view(self, section_name, replace_dict={}):
        """
        Returns HTML from a 'sections' file, replacing strings for translation
        and optionally any placeholder sections marked as '[! variable !]'

        Params:
            section_name        HTML file in 'data/ui/sections' folder
            replace_dict        Optional dictionary to replace variables
                                in format: {"variable1": "Variable 1"}
        """
        dbg.stdout("Parsing section: {0}".format(section_name), dbg.action, 1)

        try:
            with open(os.path.join(path.data_source, "ui/sections/" + section_name + ".html")) as f:
                html = f.read().replace('\n', '')
        except FileNotFoundError:
            dbg.stdout("Missing section: {0}".format(section_name), dbg.error)
            html = ""

        # Process strings
        content_strings = re.findall(r"\[\[(.*?)\]\]", html)
        for string in content_strings:
            try:
                html = html.replace("[[" + string + "]]", string_bank[string.strip()])
            except KeyError:
                dbg.stdout("String missing: '{0}' (section '{1}')".format(string.strip(), section_name), dbg.error)

        # Process variables
        for variable in replace_dict.keys():
            try:
                html = html.replace("[!" + variable + "!]", replace_dict[variable])
            except TypeError:
                dbg.stdout("Variable missing: '{0}' (section '{1}')".format(string.strip(), section_name), dbg.error)

        dbg.stdout("Loaded section: {0} ({1} strings, {2} variables)".format(section_name, len(content_strings), len(replace_dict.keys())), dbg.success, 1)

        return html

    def update_content_view(self, section_name, target_element="content", replace_dict={}):
        """
        Loads a HTML 'section' into the content view parsing string placeholders.
        """
        html = self.get_content_view(section_name, replace_dict)
        dbg.stdout("Pushed section: '{0}' (to '{1}')".format(section_name, target_element), dbg.success, 1)
        self.update_page(target_element, "html", html)

    def process_command(self, full_cmd_string):
        """
        Process a command issued from the frontend for the page.
        """
        if full_cmd_string == "null":
            return

        dbg.stdout("=> " + str(full_cmd_string), dbg.debug, 2)
        cmd = full_cmd_string.split("?")[0]

        uicmd = self.uicmd
        cmds = {
            # Main Runtime
            "quit": uicmd.close_application,
            "reload": uicmd.reload_application,

            # Devices
            "device-overview": uicmd.devices_set_overview,
            "device-select": uicmd.devices_set_device,
            "device-unrecog": uicmd.devices_set_unknown,
            "device-info": uicmd.devices_show_device_info,
            "set-effect": uicmd.set_effect,
            "set-effect-param": uicmd.set_effect_param,
            "set-brightness": uicmd.set_brightness,
            "set-game-mode": uicmd.set_gamemode,
            "set-dpi": uicmd.set_dpi,
            "set-poll-rate": uicmd.set_poll_rate,

            # Tabs
            "devices-tab": uicmd.devices_init_tab,
            "effects-tab": None,
            "schedule-tab": None,
            "preferences-tab": None
        }

        # Must run from main thread
        if cmd == "quit":
            uicmd.close_application()

        try:
            params = full_cmd_string.split("?")
            params.pop(0)
            dbg.stdout("=> {0} {1}".format(cmd, str(params)), dbg.action, 1)
            common.run_thread(uicmd.run_command(cmds[cmd], full_cmd_string))
        except KeyError:
            dbg.stdout("Unimplemented command: " + cmd, dbg.error)

        # WebKit2 quirk - clear "title" so same command can execute again
        self.run_javascript("cmd('null')")

    def start_loading(self, webkit):
        """
        Function that triggers the main application's operations.
        """
        self.webkit = webkit
        dbg.stdout("Version " + version, dbg.debug, 1)

        self.update_content_view("header", "header")
        self.update_content_view("loading")
        self.update_content_view("footer", "footer")

        dbg.stdout("Spawning daemon device manager...", dbg.debug, 1)
        if rclient:
            try:
                self.devman = rclient.DeviceManager()
                init_devices = self.devman.devices
                if len(init_devices) > 0:
                    self.active_device = init_devices[0]
            except rclient.DaemonNotFound:
                self.devman = rclient.DaemonNotFound
            except Exception as e:
                self.devman = None
                dbg.stdout("Daemon threw an exception:\n" + str(e), dbg.error, 0)

        self.uicmd = uicallback.UICmd(self, self.webkit, self.devman, get_string_bank, path.data_source)
        dbg.stdout("Application Ready.", dbg.success, 1)

        self.uicmd.devices_init_tab()


class Dialogues():
    def color_picker():
        # TODO: Ability to track and set last colour in GTK dialog.
        colorseldlg = Gtk.ColorSelectionDialog(_("Choose a Color"))
        colorsel = colorseldlg.get_color_selection()

        if colorseldlg.run() == Gtk.ResponseType.OK:
            colour = colorsel.get_current_color()
            red = int(colour.red / 256)
            green = int(colour.green / 256)
            blue = int(colour.blue / 256)
            colorseldlg.destroy()
            return "{0},{1},{2}".format(str(red), str(green), str(blue))
        else:
            colorseldlg.destroy()
            return None

    def file_picker(browse_id):
        """
        Opens a file picker and returns the string (if result is OK)

        Expects:
            browse_id       An integer that determines the settings for the dialog.

        Browse IDs:
        1       Choose icon for tray applet

        """

        if browse_id == 1:
            help_text = _("Choose an icon to use for the tray applet.")
            filter_mode = "image"
        else:
            dbg.stdout("Unimplemented file picker!", dbg.error, 1)
            return

        win = Gtk.Window(title=_("Polychromatic Controller"))
        dialog = Gtk.FileChooserDialog(help_text, win, Gtk.FileChooserAction.OPEN, \
                                       (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, \
                                        Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
        # Setup filters
        if filter_mode == "image":
            a = Gtk.FileFilter()
            a.set_name(_("All Images"))
            a.add_mime_type("image/jpeg")
            a.add_mime_type("image/png")
            a.add_mime_type("image/gif")
            a.add_mime_type("image/svg+xml")
            dialog.add_filter(a)

            j = Gtk.FileFilter()
            j.set_name("JPEG " + _("Image"))
            j.add_mime_type("image/jpeg")
            dialog.add_filter(j)

            p = Gtk.FileFilter()
            p.set_name("PNG " + _("Image"))
            p.add_mime_type("image/png")
            dialog.add_filter(p)

            g = Gtk.FileFilter()
            g.set_name("GIF " + _("Image"))
            g.add_mime_type("image/gif")
            dialog.add_filter(g)

            s = Gtk.FileFilter()
            s.set_name("SVG " + _("Image"))
            s.add_mime_type("image/svg+xml")
            dialog.add_filter(s)

        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            filename = dialog.get_filename()
            dialog.destroy()
            return filename
        else:
            dialog.destroy()
            return None


def parse_parameters():
    global _
    parser = argparse.ArgumentParser(add_help=False)
    parser._optionals.title = _("Optional arguments")
    parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
    parser.add_argument("--version", help=_("Print progran version and exit"), action="store_true")
    parser.add_argument("-v", "--verbose", help=_("Be verbose to stdout"), action="store_true")
    parser.add_argument("-vv", "-d", "--debug", help=_("Be very verbose (for debugging)"), action="store_true")
    parser.add_argument("--print-device-info", help=_("Gets a list of capabilities for a device"), action="store_true")
    parser.add_argument("--locale", help=_("Force a specific locale, e.g. de_DE"), action="store")

    # For front-end debugging (developer tools)
    parser.add_argument("--inspect", help=argparse.SUPPRESS, action="store_true")

    args = parser.parse_args()

    if args.version:
        print("Polychromatic v" + version)
        exit(0)

    if args.verbose:
        dbg.verbose_level = 1
        dbg.stdout(_("Verbose Enabled"), dbg.action, 1)

    if args.debug:
        dbg.verbose_level = 2
        dbg.stdout(_("Debug Verbose Enabled"), dbg.action, 2)

    if args.print_device_info:
        CommandLineOnly.print_device_capability_info()

    if args.inspect:
        dbg.verbose_level = 3

    if args.locale:
        _ = common.setup_translations(__file__, "polychromatic", args.locale)


if __name__ == "__main__":
    _ = common.setup_translations(__file__, "polychromatic")
    string_bank = get_string_bank(_)
    dbg = common.Debugging()

    # Compile styling when working locally.
    if dev_version:
        version = version + "-dev"

        dbg.stdout("Compiling Styling...", dbg.action)
        os.system(os.path.join(path.data_source, "../tools/build-sass.sh"))

        if not os.path.exists(os.path.join(path.data_source, "ui/css/default.css")):
            dbg.stdout("Failed to start due to missing styling.", dbg.error)
            exit(1)

    parse_parameters()
    win = AppWindow()
    app = Controller()
    win.run()
